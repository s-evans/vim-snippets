##
## Misc
snippet ovr override
	override 
snippet up std::unique_ptr
	std::unique_ptr<${1:T}>
snippet u= Alias declaration
	using ${1} = ${2};
snippet =dl = delete
	= delete
snippet =df = default
	= default
snippet ce constexpr
	constexpr
snippet ne noexcept
	noexcept
snippet static_assert C++11
	static_assert( ${1:bool_constexpr}, ${2:message} );
snippet dt decltype
	decltype(${1:expr})
snippet np nullptr
	nullptr
snippet mv std
	std::move<${1:T}>( ${2:val} )
snippet fwd std
	std::forward<${1:T}>( ${2:val} )
snippet ld Lambda expression
	[${1:capture_expression}]( ${2:args...} ){
		${3}
	}
##
## Operators
snippet opn Global Declaration (C++11)
	void* operator new ( std::size_t size );

	void* operator new ( std::size_t size, const std::nothrow_t& nothrow_value ) noexcept;

	void* operator new ( std::size_t size, void* ptr ) noexcept;

	void* operator new[] ( std::size_t size );

	void* operator new[] ( std::size_t size, const std::nothrow_t& nothrow_value ) noexcept;

	void* operator new[] ( std::size_t size, void* ptr ) noexcept;

	void operator delete ( void* ptr ) noexcept;

	void operator delete ( void* ptr, const std::nothrow_t& nothrow_constant ) noexcept;

	void operator delete ( void* ptr, void* voidptr2 ) noexcept;

	void operator delete[] ( void* ptr ) noexcept;

	void operator delete[] ( void* ptr, const std::nothrow_t& nothrow_constant ) noexcept;

	void operator delete[] ( void* ptr, void* voidptr2 ) noexcept;
snippet opn Global Definition (C++11)
	void* operator new ( std::size_t size )
	{
	}

	void* operator new ( std::size_t size, const std::nothrow_t& nothrow_value ) noexcept
	{
	}

	void* operator new ( std::size_t size, void* ptr ) noexcept
	{
		return ptr;
	}

	void* operator new[] ( std::size_t size )
	{
	}

	void* operator new[] ( std::size_t size, const std::nothrow_t& nothrow_value ) noexcept
	{
	}

	void* operator new[] ( std::size_t size, void* ptr ) noexcept
	{
		return ptr;
	}

	void operator delete ( void* ptr ) noexcept
	{
		if ( !ptr ) {
			return;
		}
	}

	void operator delete ( void* ptr, const std::nothrow_t& nothrow_constant ) noexcept
	{
		if ( !ptr ) {
			return;
		}
	}

	void operator delete ( void* ptr, void* voidptr2 ) noexcept
	{
		if ( !ptr ) {
			return;
		}
	}

	void operator delete[] ( void* ptr ) noexcept
	{
		if ( !ptr ) {
			return;
		}
	}

	void operator delete[] ( void* ptr, const std::nothrow_t& nothrow_constant ) noexcept
	{
		if ( !ptr ) {
			return;
		}
	}

	void operator delete[] ( void* ptr, void* voidptr2 ) noexcept
	{
		if ( !ptr ) {
			return;
		}
	}
##
## Enums
snippet ec std
	enum class ${1:T} {
		${2}
	};
snippet tec std
	typedef enum class ${1:T} {
		${2}
	} $1_T;
snippet es std
	enum struct ${1:T} {
		${2}
	};
snippet tes std
	typedef enum struct ${1:T} {
		${2}
	} $1_T;
snippet eb std
	enum ${1:T} : ${2:base_type} {
		${3}
	};
snippet teb std
	typedef enum ${1:T} : ${2:base_type} {
		${3}
	} $1_T;
snippet esb std
	enum struct ${1:T} : ${2:base_type} {
		${3}
	};
snippet tesb std
	typedef enum struct ${1:T} : ${2:base_type} {
		${3}
	} $1_T;
snippet ecb std
	enum class ${1:T} : ${2:base_type} {
		${3}
	};
snippet tecb std
	typedef enum class ${1:T} : ${2:base_type} {
		${3}
	} $1_T;
##
## Iteration
snippet for For loop using iterators (C++11)
	for ( auto ${1:i} = ${2:container}.begin() ; $1 != $2.end() ; ++$1 ) {
		${3}
	}
snippet for Range-based for loop (C++11)
	for ( ${1:auto} ${2:i} : ${3:container} ) {
		${4}
	}
##
## Effective STL
snippet shrink_to_fit C++11
	${2:collection}.shrink_to_fit();
## 
## Type Traits
snippet integral_constant std
	std::integral_constant<${1:T}, ${2:T v}>
snippet true_type std
	std::true_type
snippet false_type std
	std::false_type
snippet is_void std
	std::is_void<${1:T}>::value
snippet is_null_pointer std
	std::is_null_pointer<${1:T}>::value
snippet is_integral std
	std::is_integral<${1:T}>::value
snippet is_floating_point std
	is_convertiblestd::is_floating_point<${1:T}>::value
snippet is_array std
	std::is_array<${1:T}>::value
snippet is_pointer std
	std::is_pointer<${1:T}>::value
snippet is_lvalue_reference std
	std::is_lvalue_reference<${1:T}>::value
snippet is_rvalue_reference std
	std::is_rvalue_reference<${1:T}>::value
snippet is_member_object_pointer std
	std::is_member_object_pointer<${1:T}>::value
snippet is_member_function_pointer std
	std::is_member_function_pointer<${1:T}>::value
snippet is_enum std
	std::is_enum<${1:T}>::value
snippet is_union std
	std::is_union<${1:T}>::value
snippet is_class std
	std::is_class<${1:T}>::value
snippet is_function std
	std::is_function<${1:T}>::value
snippet is_reference std
	std::is_reference<${1:T}>::value
snippet is_arithmetic std
	std::is_arithmetic<${1:T}>::value
snippet is_fundamental std
	std::is_fundamental<${1:T}>::value
snippet is_object std
	std::is_object<${1:T}>::value
snippet is_scalar std
	std::is_scalar<${1:T}>::value
snippet is_compound std
	std::is_compound<${1:T}>::value
snippet is_member_pointer std
	std::is_member_pointer<${1:T}>::value
snippet is_const std
	std::is_const<${1:T}>::value
snippet is_volatile std
	std::is_volatile<${1:T}>::value
snippet is_trivial std
	std::is_trivial<${1:T}>::value
snippet is_trivially_copyable std
	std::is_trivially_copyable<${1:T}>::value
snippet is_standard_layout std
	std::is_standard_layout<${1:T}>::value
snippet is_pod std
	std::is_pod<${1:T}>::value
snippet is_literal_type std
	std::is_literal_type<${1:T}>::value
snippet is_empty std
	std::is_empty<${1:T}>::value
snippet is_polymorphic std
	std::is_polymorphic<${1:T}>::value
snippet is_abstract std
	std::is_abstract<${1:T}>::value
snippet is_signed std
	std::is_signed<${1:T}>::value
snippet is_unsigned std
	std::is_unsigned<${1:T}>::value
snippet is_constructible std
	std::is_constructible<${1:T}, ${2:... Args}>::value
snippet is_default_constructible std
	std::is_default_constructible<${1:T}>::value
snippet is_copy_constructible std
	std::is_copy_constructible<${1:T}>::value
snippet is_move_constructible std
	std::is_move_constructible<${1:T}>::value
snippet is_assignable std
	std::is_assignable<${1:T}, ${2:U}>::value
snippet is_copy_assignable std
	std::is_copy_assignable<${1:T}>::value
snippet is_move_assignable std
	std::is_move_assignable<${1:T}>::value
snippet is_destructible std
	std::is_destructible<${1:T}>::value
snippet is_trivially_constructible std
	std::is_trivially_constructible<${1:T}, ${2:... Args}>::value
snippet is_trivially_default_constructible std
	std::is_trivially_default_constructible<${1:T}>::value
snippet is_trivially_copy_constructible std
	std::is_trivially_copy_constructible<${1:T}>::value
snippet is_trivially_move_constructible std
	std::is_trivially_move_constructible<${1:T}>::value
snippet is_trivially_assignable std
	std::is_trivially_assignable<${1:T}, ${2:U}>::value
snippet is_trivially_copy_assignable std
	std::is_trivially_copy_assignable<${1:T}>::value
snippet is_trivially_move_assignable std
	std::is_trivially_move_assignable<${1:T}>::value
snippet is_trivially_destructible std
	std::is_trivially_destructible<${1:T}>::value
snippet is_nothrow_constructible std
	std::is_nothrow_constructible<${1:T}, ${2:... Args}>::value
snippet is_nothrow_default_constructible std
	std::is_nothrow_default_constructible<${1:T}>::value
snippet is_nothrow_copy_constructible std
	std::is_nothrow_copy_constructible<${1:T}>::value
snippet is_nothrow_move_constructible std
	std::is_nothrow_move_constructible<${1:T}>::value
snippet is_nothrow_assignable std
	std::is_nothrow_assignable<${1:T}, ${2:U}>::value
snippet is_nothrow_copy_assignable std
	std::is_nothrow_copy_assignable<${1:T}>::value
snippet is_nothrow_move_assignable std
	std::is_nothrow_move_assignable<${1:T}>::value
snippet is_nothrow_destructible std
	std::is_nothrow_destructible<${1:T}>::value
snippet has_virtual_destructor std
	std::has_virtual_destructor<${1:T}>::value
snippet alignment_of std
	std::alignment_of<${1:T}>::value
snippet rank std
	std::rank<${1:T}>::value
snippet extent std
	std::extent<${1:T}, ${2:I = 0}>::value
snippet is_same std
	std::is_same<${1:T}, ${2:U}>::value
snippet is_base_of std
	std::is_base_of<${1:Base}, ${2:Derived}>::value
snippet is_convertible std
	std::is_convertible<${1:From}, ${2:To}>::value
snippet add_const std
	std::add_const<${1:T}>::type
snippet add_cv std
	std::add_cv<${1:T}>::type
snippet add_lvalue_reference std
	std::add_lvalue_reference<${1:T}>::type
snippet add_pointer std
	std::add_pointer<${1:T}>::type
snippet add_rvalue_reference std
	std::add_rvalue_reference<${1:T}>::type
snippet add_volatile std
	std::add_volatile<${1:T}>::type
snippet decay std
	std::decay<${1:T}>::type
snippet make_signed std
	std::make_signed<${1:T}>::type
snippet make_unsigned std
	std::make_unsigned<${1:T}>::type
snippet remove_all_extents std
	std::remove_all_extents<${1:T}>::type
snippet remove_const std
	std::remove_const<${1:T}>::type
snippet remove_cv std
	std::remove_cv<${1:T}>::type
snippet remove_extent std
	std::remove_extent<${1:T}>::type
snippet remove_pointer std
	std::remove_pointer<${1:T}>::type
snippet remove_reference std
	std::remove_reference<${1:T}>::type
snippet remove_volatile std
	std::remove_volatile<${1:T}>::type
##
## Class
snippet cl Class declaration (C++11)
	class ${1:`vim_snippets#Filename('$1', 'name')`} 
	{
	public:

		/**
		 * CTOR
		 */
		$1( ${2} );

		/**
		 * DTOR
		 */
		~$1();

		/**
		 * Default CTOR
		 */
		$1() = delete;

		/**
		 * Copy constructor
		 */
		$1( $1 const& ) = delete;

		/**
		 * Assignment operator
		 */
		$1& operator=( $1 const& ) = delete;

		/**
		 * Move constructor
		 */
		$1( $1&& ) = delete;

		/**
		 * Move assignment operator
		 */
		$1& operator=( $1&& ) = delete;

	private:
		${0:/* data */}

	};
snippet op= Declaration (C++11)
	${1:`vim_snippets#Filename('$1', 'ClassName')`}( $1 const& rhs );

	$1& operator=( $1 const& rhs );

	$1( $1&& );

	$1& operator=( $1&& );
snippet op= Definition (C++11)
	${1:`vim_snippets#Filename('$1', 'ClassName')`}::$1( $1 const& rhs )
	{
	}

	$1& $1::operator=( $1 const& rhs )
	{
		if ( this == &rhs ) return *this;

		return *this;
	}

	$1::$1( $1&& rhs )
	{
	}

	$1& $1::operator=( $1&& rhs )
	{
		if ( this == &rhs ) return *this;

		return *this;
	}
##
## Allocator
snippet alloc custom allocator class template outline (C++11)
	#include <cstddef>
	#include <new>

	template <class T>
	class ${1:`vim_snippets#Filename('$1', 'name')`} 
	{

	public:

		// Member types
		typedef T                 value_type;
		typedef value_type*       pointer;
		typedef const value_type* const_pointer;
		typedef value_type&       reference;
		typedef const value_type& const_reference;
		typedef std::size_t       size_type;
		typedef std::ptrdiff_t    difference_type;

		template <class U>
		struct rebind {
			typedef $1<U> other;
		};

		/**
		 * Default constructor
		 */
		$1() noexcept
		{
			// TODO: Implement
		}

		/**
		 * Copy constructor
		 */
		$1( const $1& rhs ) noexcept
		{
			// TODO: Implement
		}

		/**
		 * Move constructor
		 */
		$1( const $1&& rhs ) noexcept
		{
			// TODO: Implement
		}

		/**
		 * Move assignment operator
		 */
		$1& operator=( $1&& rhs ) noexcept
		{
			if ( this == &rhs ) return *this;

			// TODO: Implement

			return *this;
		}

		/**
		 * Assignment operator
		 */
		$1& operator=( const $1& rhs ) noexcept
		{
			if ( this == &rhs ) return *this;

			// TODO: Implement

			return *this;
		}

		/**
		 * Rebind constructor
		 */
		template <class U>
		$1( const $1<U>& rhs ) noexcept
		{
			// TODO: Implement
		}

		/**
		 * Destructor
		 */
		~$1() noexcept
		{
			// TODO: Implement
		}

		/**
		 * Obtains the address of an object, even if operator& is overloaded
		 */
		pointer address( reference x ) const noexcept
		{
			return &x;
		}

		/**
		 * Obtains the address of an object, even if operator& is overloaded
		 */
		const_pointer address( const_reference x ) const noexcept
		{
			return &x;
		}

		/**
		 * Allocates uninitialized storage
		 */
		pointer allocate( size_type n, const_pointer hint = 0 )
		{
			// TODO: Implement
			void* p = 0;

			if ( !p ) {
				throw std::bad_alloc();
			}

			return static_cast<pointer>( p );
		}

		/**
		 * Deallocates storage
		 */
		void deallocate( pointer p, size_type n ) noexcept
		{
			// TODO: Implement
		}

		/**
		 * Returns the largest supported allocation size
		 */
		size_type max_size() const noexcept
		{
			return static_cast<size_type>( -1 ) / sizeof( value_type );
		}

		/**
		 * Constructs an object in allocated storage
		 */
		void construct( pointer p, const value_type& x )
		{
			new( p ) value_type( x );
		}

		/**
		 * Destructs an object in allocated storage
		 */
		void destroy( pointer p )
		{
			p->~value_type();
		}

	private:

		// data

	};

	// Void specialization

	template<>
	class $1<void>
	{

	public:

		// Member Types
		typedef void        value_type;
		typedef void*       pointer;
		typedef const void* const_pointer;

		template <class U>
		struct rebind {
			typedef $1<U> other;
		};

	};

	// Free Functions

	template <class T>
	inline bool operator==( const $1<T>&, const $1<T>& ) noexcept
	{
		return true;
	}

	template <class T>
	inline bool operator!=( const $1<T>&, const $1<T>& ) noexcept
	{
		return false;
	}

